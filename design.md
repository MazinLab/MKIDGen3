# UCSB Gen3 Design
This document is in flux and resource calculations are only partially done. Some of the linked projects do not yet exist or are untested (especially in the timekeeping/triggering area of the design) and the names and links are suggestive placeholders. In some cases there are alternative/backup approaches that are not described.

There is this, the one [python git repo](https://github.com/MazinLab/MKIDGen3) for the control software and several repos for Vivado designs and HLS blocks, the top level design is [here](https://github.com/MazinLab/gen3-vivado-top).


#General Clocking, Reset, and capture design
## Clocks:
1. 128 MHz clk_adc1. Used for control of axilite and generating 512MHz clock. From ADC PLL.
2. 256 clk_dac. Used for the dac_replay block. From the DAC PLL
3. 512 MHz pipeline clock. Generated by from an MMCM in a clock wizard from the 128MHz clock.
4. 333 MHz DDR4 clock. Used to read/write from the PL DDR4. Generated by the MIG.

### Resets
Tied off for all but the RFDC per its datasheet.

### Stream Capture
AXI4S broadcasters are used in various hierarchies to route the data streams to either [adc_capture](https://github.com/MazinLab/iq-capture), iq_capture, or phase_capture core (latter two in same repo, all dataflow ap_ctrl_hs with sub-functions using pipelined for loops). A stream switch is used to pick between iq or phase streams. These cores each have an AXI4M routed to a SmartConnect that then drives to the PLDDR4 MIG. A PS AXI master is also connected to the smartconnect to allow reading out the DDR4. 

## RF Data Converter Block
Detailed configuration of this block is TBD.

## Frequency Comb Generation / DAC Replay 
The comb is computed in python using repackaged code from gen2 on a per-feedline basis. (TODO Modify the gen2 code so it uses sane amounts of ram.) The comb, as a 2x8x2^15 element LUT, is loaded as signed shorts into the [DAC 
Replay core](https://github.com/MazinLab/dac-replay-ip) via `gen3.pynq.DACTableAXIM.replay()`

#### DAC Replay Core
HLS (`#pragma HLS INTERFACE s_axilite port=return bundle=control`) with an AXI4 Master, three AXIS Masters, and a few axilite control params. Clocked directly from RFDC clk_dac1 output @ 256 MHZ. Uses 60 URAMS for up to 2MiB of replay buffer.

The core has two loops, the first fetches and fills the replay buffer. The second pipelined with an II=1, runs as long as the run bit is set, replaying the from the buffer with whatever settings the core was started with. 

AXI4M:
 - Issues 128b reads directly to PS DDR via S_AXI_HP0_FPD @ 256MHz

AXIS:
- I to DAC10 (256b)
- Q to DAC11 (256b)
- IQ words with TUSER and TLAST for debugging (512,8,1b)

## Photon Processing Pipeline
The ADC readout subsystem is significantly more complicated than the comb generator. It consists of an oversampled polyphase filter bank (OPFB), followed by resonator channel selector, direct digital down conversion, low-pass
filtering, iq->phase conversion, optimal filtering, event triggering, and capture. Presently the design has roughly complete to the low-pass point, with most of the work done through the optimal filtering stage.

The hierarchy is: photon_pipe/
- opfb/
- reschan/
- phase_proc/ (note that this is still being implemented)
  - axis data width converter
  - 4 cordics (IQ to phase)
  - 2 axi-stream fifos for config and reload packet generation (at 128MHz, might use just one) 
  - 4x FIRs in 512 channel mode
  - various broadcasters and combiners


### Overlapped Polyphase Filter
The photon_pipe/opfb hierarchy takes in the I and Q stream each from an ADC and yields an IQ stream. There are no control lines. 

Flow in the block goes through the HLS [adc-to-opfb](https://github.com/MazinLab/adc-to-opfb) block (dataflow, 2 functions, all ap_ctrl_none), then into the fir hierarchy where it is sliced/broadcast into bank of 16 FIR Compiler blocks configured by a small HLS coefficient select block ([opfb-fir-cfg](https://github.com/MazinLab/opfb-fir-cfg)) that runs once when the bitstream is loaded. 

The FIR outputs are merged with an axis combiner, fed through the[opfb-fir-to-fft](https://github.com/MazinLab/opfb-fir-to-fft) HLS block for processing (pipeline ii=1, flat, ap_ctrl_none), to an axis broadcast/slice, and into a super sample rate 4096 point FFT block exported from sysgen (16x256). The output of the FFT is packaged back into a single AXIS stream by [pkg-fft-output](https://github.com/MazinLab/pkg-fft-output) (pipeline ii=1, flat, ap_ctrl_none, ap_vld on the inputs). This last block generates the TLAST signal from an internal counter.

Hierarchy: photon_pipe/opfb/
- adc_to_opfb
- firs/
  - broadcast w/ slice
  - firs (w/ fft_config)
  - combiner
- fir_to_fft
- fft/
  - broadcast w/ slice
  - SSR FFT (4096 16x256)
  - pkg_fft_output

In:
- 256b AXI4S of 16b I words @ 512MHz
- 256b AXI4S of 16b Q words @ 512MHz

Out:
- 512b AXI4S of 16 16b IQ equipped with TUSER (16b, the 12b fft scale output) and TLAST every 256 transactions.

Utilization:
- for 8 taps: 256 (FIR) + 144 (FFT) DSP48
- for 4 taps: ~17% LUT (20% or LUTRAM) 6% FF, 0.7% BRAM, 3.5% DSPs

### Resonator Channelization
The blocks here select 2048 IQ streams from the 4096 FFT IQ bins, digitally down-convert the IQs, and then lowpass and decimate (2:1) them. The selection is done by the [bin-to-res](https://github.com/MazinLab/bin-to-res) (pipelined II=1, ap_ctrl_none, flat, axilite port for resmap) and the DDC by the [resonator-ddc](https://github.com/MazinLab/resonator-dds) (git repo is a misnomer) block (ap_ctl_none, pipelined ii=1, pipelined subfunctions, axilite port for tone control).


Hierarchy: photon_pipe/reschan/
- bin_to_res
- broadcast to debug capture
- resonator_ddc
- broadcast to debug capture
- lowpass fir
- broadcast to debug capture


Inputs: 
- 512b AXI4S of 16 16b complex numbers, with TLAST
- AXI-Lite resonator map port
- AXI-Lite resonator tone port

Outputs:
- 256b AXI4S of 8 16b complex, with TLAST, TUSER (group), valid every other clock (256MHz data @ 512MHz)
- AXI4S debug streams for capturing raw ADC IQ and DDCd IQs

Utilization: TODO

### Phase Conversion
Under active development
Datawidth converter

##Individual core details (largely out of date)


#### adc-to-opfb
Inputs: 
- I 128bit AXI4S of 16 bit words
- Q 128bit AXI4S of 16 bit words

Outputs:
- 16x IQ 32bit AXI4S of 16bit complex words, streams equipped with TLAST.

This block takes the incoming 8 I & Q samples and bundles them into complex shorts for internal operations. It then
breaks the 8 IQ into 16 by applying feeding the even and odd lanes with every other sample (i.e. sample 0, 16, 32 -> 
lane0; 8, 24, 40 -> lane1; sample 1, 17, 33 -> lane2; etc). Each lane keeps a delay line of 128 samples and uses the
delay line to drive the output in 'off' cycles, thereby resulting in output that looks like 0, -127, 1, -126, ... 
for a given lane. The resulting pattern may be seen in full, along with the intended FIR coefficient set (TODO) for
multiplication in the simulation output. TLAST (TODO) is set on the 256th cycle of each lane. 

#### FIR Bank & Control
The 16 FIRs are configured for 512 channel 2 parallel path 16 bit input, 18 bit output with 256 coefficient sets.
Configuration is by channel with the channel HLS block configuring coefficient set order as 0, 0, 1, 1, 2, 2, ....
Coefficient reload is disabled. The FIRs are not presently planned to do anything with axi4s side channel
information aside from TLAST passthrough. TODO: Revisit side channel handling for datastream framing as OPFB progresses.

#### opfb-fir-to-fft
Inputs: 
- IQ 36bit AXI4S of 18 bit complex equipped with TLAST

Output: 
- IQ 36bit AXI4S of 18 bit complex equipped with TLAST

This block takes an IQ stream from a lane's FIR and reorderes them as needed to feed the FFT. It breaks the incoming
stream into even (group A) and odd samples, with the odd samples grouped into a group of the first 128 (group B) and the
second 128 (group C). Samples are stored in internal FIFOs and sent on in order from group A, then C, then B, thereby
achieving the alternating cycle reorder required by the OPFB. The results of the are available from the C simulation of
the core.

#### Vector FFT
Inputs: 
- 16x IQ 36bit AXI4S of 18 bit complex equipped with TLAST

Output: 
- 1 576bit AXI4S of 16 18 bit complex equipped with TLAST

The FFT is done by the Xilinx Vector FFT from the SSR Blockset for System Generator. The inputs into the FFT must be
connected in an interleaved fashion to ensure the expected natural bin order. The first 8 inputs coming from the even
lanes and the second 8 inputs from the odd lanes. TLAST is asserted on the cycle containing the last 16 bins of the FFT.

The HLS SSR FFT is not used as of HLx 2019.2 as:
- There are windows/linux compile issues
- Initial tests show it may not make timing

#### opfb-bin-to-res Selection
Inputs: 
- 2 288bit AXI4S of 16 18 bit numbers (I and Q streams), both equipped with TLAST
- AXI-Lite resonator map port (256x8 ap_uint<12> array).

Outputs:
- 1 288bit AXI4S of 8 18 bit complex equipped with TLAST and possibly (TODO) TKEEP

The resonator selection [HLS block](https://github.com/MazinLab/opfb-bin-to-res) ingests the IQ bins output by the
OPFB subsystem and extracts and outputs the IQ values corresponding to resonators. This is done by caching the bin
spectrum (updating the next 16 bins each clock) and fetching 8 bins containing resonators each clock. This is
implemented as 8 banks of ~147kbit BRAM in order to have sufficient memory ports. The bins used are stored in a bin
to resonator LUT (2048 x 12 bits) loaded in from python via AXI Lite. 

####  resonator-dds
Inputs: 
- 1 288bit AXI4S of 8 18 bit complex equipped with TLAST and possibly (TODO) TKEEP or TUSER
- Quarter wave SIN/COS LUT of length... This is implemented in ROM and sized to support 8 simultaneous reads.
- Resonator frequency table stored as a phase increment LUT.
- Resonator phase shift table stored as a phase zero.

Outputs:
- 1 288bit AXI4S of 8 18 bit complex equipped with TLAST and possibly (TODO) TKEEP

Utilization:
- 24 DSP48

The HLS block uses the TLAST on the inbound stream to keep track of the cycle and query phase and phase increment
LUTs for the received group of resonators. These are used increment/maintain an accumulated phase for each resonator
which is used to query a quarter-wave sin/cos LUT (stored in ROM). Phase offsets are used to apply a per-resonator 
phase shift (rotate loops in gen2 parlance). Presently the result is neither dithered nor Taylor corrected, however
there is example Xilinx HLS code for how to implement those features as well. The resulting sin/cos values are fed 
into a Xilinx complex multiplier (3 DSP slices per IQ, 24 in total) and the results passed out of the block.

#### FIR Core
Utilization:
- 320 (or 240) 

The fir is configured for 256 channel, 16 parallel channel (8I, 8Q) operation with 20 taps and 18 bit IO. It is
configured for a decimation of 2, dropping the sample rate to 1 MHZ. This takes ~320 DSP slices, though the core
itself should be able to run at ~820MHz, so with a clock crossing we could run with 8 to 6 to 8 lanes for a total of
240 DSP slices.

### Resonator Processing
Inputs: 
- 288bit AXI4S of 8 18 bit complex equipped with TLAST and possibly (TODO) TKEEP or TUSER
- Timestamp

Outputs:
- 88bit AXI4S photon stream (18bit phase, 18bit baseline, 32bit time, 16bit resID)

IO:
- AXI4M Port
    - Matched filter configuration (in)
    - Per-resonator dropped photon counter (out)
    - FL ID (to convert resonance to resonatorID) (in)
    - Trigger configuration (in)

The [resonator processor subsystem](https://github.com/MazinLab/gen3-resproc) takes in the stream from the 
channelization and breaks it into separate lanes of 256 resonators which are fed into 8 instances of the resonator
[lane subsystem](https://github.com/MazinLab/resonator-stream-lane). It breaks the stream via an HLS block and
implements an Xilinx MCDMA module to route the required configuration streams to the lane subsystems. The lane
subsystems yield triggered photon packets on an XXX (TODO) output, which are gathered by XXX, and output as a stream
of photons. NB that 2500 photons/s * 2048 resonators/FL is ~5e6, so this stream can run quite slowly. 

#### iq-stream-split
This HLS block takes an 8 wide IQ stream and breaks it into 8 streams, attaching the full resonator ID as TUSER.

#### lane-subsystem
Inputs:
- AXI4S 36bit IQ stream with 16bit TUSER
- AXI4S FIR Reload
- ??? Trigger config
- time register

Outputs:
- ??? Photon events

Utilization:
- 200 DSP slices, 138 if FIR at 768MHz (assuming 50/51 taps)

The lane subsystem routes the incoming IQ stream into a Xilinx cordic block configured for arctangent operation, the
resulting stream is then sent to and FIR Compiler core for matched filtering, finally the resulting filtered stream
is routed to to the HLS [photon-trigger](https://github.com/MazinLab/photon-trigger) block which outputs a stream of
photon events.

##### FIR block and HLS channel config
- 200 DSP slices, 138 if FIR at 768MHz (assuming 50/51 taps)

The FIR is configured for 256 channel operation with 51 taps for 256 reloadable coefficient sets and 18 bit IO
It is configured to operate at 768 MHz and for by channel coefficient operation. This takes 17 DSP slices. The
channel configuration is streamed in 0,1,2,3... from a simple VHDL block. The reload channel is an input to the
subsystem. TUSER is passed through.

##### photon-detect
This HLS block takes in the matched phase stream and performs a baseline filter and trigger. It outputs photons on a
fifo photon stream (18bit phase, 18bit baseline, 32bit time, 16bit resID)

#### Photon Packaging
This TBD block combines photons output by the eight lanes and combines them into a photon stream for the feedline. At
2500 photons per second on a full feedline this would be a ~450Mbit stream ~90 bits wide. 

### Photon Processing
This subsystem takes in a (multiple? TDB) photon stream(s) and ships the events off to the PS via AXI4M. The PS
system will then in turn write them them to the instrument disk via an NFS mount. We may also want this block to
maintain some statistics about the photon stream. This statistics would be operating on a ~0.5 - 2 Gbit stream.
